'스프링 컨테이너'
ApplicationContext : 스프링 컨테이너, 인터페이스(다형성)
기존에는 AppConfig 를 사용해서 직접 객체를 생성하고 DI를 했지만, 스프링컨테이너를 사용할 것
스프링 컨테이너는 @Configuration 이 붙은 AppConfig 를 구성정보로 사용한다.
@Bean 이라 적힌 메서드를 모두 호출해서 반환된 객체를 스프링 컨테이너에 등록하고 이를 스프링 빈이라고 한다.
@Bean 이 붙은 메서드의 명을 스프링 빈의 이름으로 사용한다.

AnnotationApplicationContext 는 ApplicationContext 의 구현체이다.
스프링 컨테이너 안에 스프링 빈 저장소 안에 빈 이름, 빈 객체 등을 생성한다. (@Bean 이 붙은, 메서드 이름을 빈 이름으로)
@Bean(name="") 으로 임의로 부여할 수 있다. 항상 다른 이름을 부여하자.
스프링 컨테이너는 설정 정보를 참고해서 의존관계를 주입한다.(DI)


* 싱글톤 패턴 *
싱글톤 패턴을 적용하면 고객의 요청이 올때 마다 객체를 생성하는 것이 아니라, 이미 만들어진 객체를 공유해서 효율적으로 사용할 수 있다.
'문제점'
1. 코드 자체가 많이 들어간다
2. 의존관계상 getInstance() 해야하기 때문에 구현체 클래스에 의존한다 -> DIP 위반한다.
3. OCP 원칙 위반
4. 테스트의 어려움
5. 내부 속성 변경 및 초기화 어려움
6. private 생성자로 자식 클래스 만들기 어려움
7. 유연성 떨어짐

싱글톤 컨테이너 (=스프링 컨테이너)
싱글톤 패턴의 문제점을 해결하면서 객체 인스턴스를 싱글톤(1개만 생성)으로 관리한다.
=> Spring Bean

싱글톤 방식의 주의점
* 여러 클라이언트가 하나의 같은 객체 인스턴스를 공유하기 때문에 '무상태(stateless)'로 설계해야함
- 특정 클라이언트에 의존적인 필드가 있으면 안된다
- 특정 클라이언트가 값을 변경할 수 있는 필드가 있으면 안된다
- 가급적 읽기만 가능해야한다
- 필드 대신에 자바에서 공유되지 않는 지역변수, 파라미터, ThreadLocal 등을 사용해야한다.

@ComponentScan 은 @Component 가 붙은 모든 클래스를 스프링 빈으로 등록한다.
이때 스프링 빈의 기본 이름은 클래스면을 사용하되 맨 앞글자만 소문자를 사용한다.
직접 지정도 가능함. @Component("memberService")

스프링 부트 사용 시, 대표 시작 정보인 @SpringBootApplication 을 루트에 두고 -> 이 설정 안에 @ComponentScan 들어있다.
* 컴포넌트 스캔 기본 대상 (자동)
@Component : 컴포넌트 스캔에서 사용
@Controller : 스프링 MVC 컨트롤러에서 사용 + MVC 컨트롤러로 인식
@Service : 스프링 비즈니스 로직에서 사용
@Repository : 스프링 데이터 접근 계층에서 사용 + 스프링 데이터 접근 계층으로 인식하고, 데이터 계층의 예외를 스프링 예외로 변환
@Configuration : 스프링 설정 정보에서 사용 + 스프링 빈이 싱글톤으로 유지하도록 추가 처리

* 참고 : 어노테이션은 자바 기능이 아니고 스프링 기능이다! 상속관계 없음

수동 빈 등록 vs 자동 빈 등록의 경우, 수동 빈 등록이 우선권 가진다(Overriding... ) -> 최근 스프링에서 충돌로 에러 변경
spring.main.allow-bean-definition-overriding=true // 설정 가능하도록 변경

< 다양한 의존관계 주입 방법 >
1. 생성자 자동주입
- 생성자 위에 @Autowired
- 생성자 호출 시점에 딱 1번만 호출 보장, '불변, 필수' 의존관계에 사용
- ** 중요 ! 생성자가 1개 있으면 Autowired 안붙여줘도 괜찮다 (생략가능) **

2. 수정자 주입
- setXXX (setter)에 @Autowired
- 연관관계(의존관계) 자동주입(@Autowired) 찾아서 주입
- 생성자 주입 후 의존 관계 주입
- 선택, 변경 가능성이 있는 의존관계에 사용

3. 필드 주입
- 외부에서 변경하기 힘들어서 테스트하기 힘들다.
- 왠만해서는 사용하지 말자! 대신 Test 자체 안에서는 사용하면 편하긴 하다

4. 일반 메서드 주입
- 한번에 여러 필드를 주입 받을 수 있지만 거의 사용안함

** 의존관계 자동 주입은 스프링 컨테이너가 관리하는 스프링 Bean 이어야지만 동작한다.

* 생성자 주입을 선택해야하 하는 이유!! *
1. 불변
2. 누락
- 수정자 주입을 포함한 나머지 주입 방식은 모두 생성자 이후에 호출되므로, 필드에 final 키워드를 사용할 수 없다.
오직 생성자 주입 방식만 final 키워드 쓸 수 있음
생성자 주입방식을 선택하는 이유는 프레임워크에 의존하지 않고 순수한 자바 언어의 특즹을 잘 살리는 방법
기본 생성자 주입하고 필수 값이 아닌 경우 수정자 주입방식을 옵션으로 부여하고 동시에 사용하자 필드 주입은 사용하지 말자

@Autowired 매칭 정리
1. 타입매칭
2. 타입 매칭의 결과가 2개 이상일 때 필드명, 파라미터 명으로 빈 이름 매칭 -> rateDiscountPolicy
3. @Qualifier 사용 (Qualifier 는 끼리끼리)
4. @Primary : 우선순위를 정하는 방법, 우선권 가진다. 만약, Primary 랑 Qualifier 있으면 Qualifier (즉 자세한) 우선순위가 더 높다.

